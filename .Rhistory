for (i in 1:M){
#### generate dataset
X = data.frame(matrix(nrow = d*n, ncol = d))
for (i in 1:d){
X[(1+(i-1)*n):(i*n), pattern[[i]]] = mvrnorm(n, rep(0, d-1), SigmaS[[i]])
}
X = as.matrix(X)
### run little's test
little_decisions[i] = little_test(X, alpha = 0.05, type = "cov")
}
return(mean(little_decisions))
}
#### parallel using parallel
bootstrap_power = function(t1){
#### POPULATION LEVEL ######
v = 1:d
pattern = list()
for (i in 1:d){
pattern[[i]] = v[-i]
}
card_patterns = length(pattern)
SigmaS=list()
A = matrix(runif(d^2)*2-1, ncol=d)
Sigma = cov2cor(t(A) %*% A)
for(j in 1:card_patterns){
yyy = matrix(runif((d-1)^2)*2-1, ncol=d-1)
SigmaS[[j]]= (d-t1)*as.matrix(Sigma[pattern[[j]],pattern[[j]]])/d +
t1*cov2cor(t(yyy) %*% yyy)/d
}
our_decisions = logical(length = M)
for (i in 1:M){
#### generate dataset
X = data.frame(matrix(nrow = d*n, ncol = d))
for (i in 1:d){
X[(1+(i-1)*n):(i*n), pattern[[i]]] = mvrnorm(n, rep(0, d-1), SigmaS[[i]])
}
X = as.matrix(X)
### run our tests
our_decisions[i] = MCAR_corr_test(X, alpha = 0.05, B = 99, type = "np")
}
return(mean(our_decisions))
}
xxx = (0:7)/2
### work in parallel
registerDoFuture()
plan(multicore)
RNGkind("L'Ecuyer-CMRG")
set.seed(232)
start.time = Sys.time()
R = foreach(kkk = xxx, .combine = 'c') %dorng% computeR_kkk(kkk)
little_power = foreach(kkk = xxx, .combine = 'c') %dorng% little_power(kkk)
little_power_cov = foreach(kkk = xxx, .combine = 'c') %dorng% little_power_cov(kkk)
our_power = foreach(kkk = xxx, .combine = 'c') %dorng% bootstrap_power(kkk)
end.time = Sys.time()
time.taken = round(end.time - start.time, 2)
time.taken
# plot the simulation
png(paste("pictures/all_but_one-",d, ".png"))
plot(R, little_power, col="green", ylim = c(0,1), pch=18, xlab = "", ylab = "", type = "b")
lines(R, little_power_cov, col="orange", pch=18, type = "b")
lines(R, our_power, col="blue", pch=18, type = "b")
abline(h = alpha, col="red")
legend("center",
legend = c("Little's power", "Little's power cov", "Our power"),
col = c("green", "orange", "blue"),
pch = c(18, 18, 18))
dev.off()
source("computeR.R")
source("little_test.R")
source("bootstrap_test.R")
source("find_SigmaS.R")
library(missMethods)
library(MASS)
library(norm)
library(missMethods)
library(MASS)
library(norm)
library(foreach)
library(doSNOW)
library(doParallel)
library(future)
library(parallel)
library(foreach)
library(doRNG)
library(doFuture)
library(future.apply)
######### 3-cycle: setting 1 ############
alpha = 0.05
n = 200
M = 40
d = 3
##### easy part
computeR_kkk = function(t1){
#### POPULATION LEVEL ######
v = 1:d
pattern = list()
for (i in 1:d){
pattern[[i]] = v[-i]
}
card_patterns = length(pattern)
SigmaS=list()
A = matrix(runif(d^2)*2-1, ncol=d)
Sigma = cov2cor(t(A) %*% A)
for(j in 1:card_patterns){
yyy = matrix(runif((d-1)^2)*2-1, ncol=d-1)
SigmaS[[j]]= (10-t1)*as.matrix(Sigma[pattern[[j]],pattern[[j]]])/10 +
t1*cov2cor(t(yyy) %*% yyy)/10
}
return(computeR(patterns = pattern, SigmaS = SigmaS)$R)
}
little_power = function(t1){
#### POPULATION LEVEL ######
v = 1:d
pattern = list()
for (i in 1:d){
pattern[[i]] = v[-i]
}
card_patterns = length(pattern)
SigmaS=list()
A = matrix(runif(d^2)*2-1, ncol=d)
Sigma = cov2cor(t(A) %*% A)
for(j in 1:card_patterns){
yyy = matrix(runif((d-1)^2)*2-1, ncol=d-1)
SigmaS[[j]]= (d-t1)*as.matrix(Sigma[pattern[[j]],pattern[[j]]])/d +
t1*cov2cor(t(yyy) %*% yyy)/d
}
little_decisions = logical(length = M)
for (i in 1:M){
#### generate dataset
X = data.frame(matrix(nrow = d*n, ncol = d))
for (i in 1:d){
X[(1+(i-1)*n):(i*n), pattern[[i]]] = mvrnorm(n, rep(0, d-1), SigmaS[[i]])
}
X = as.matrix(X)
### run little's test
little_decisions[i] = little_test(X, alpha = 0.05)
}
return(mean(little_decisions))
}
little_power_cov = function(t1){
v = 1:d
pattern = list()
for (i in 1:d){
pattern[[i]] = v[-i]
}
card_patterns = length(pattern)
SigmaS=list()
A = matrix(runif(d^2)*2-1, ncol=d)
Sigma = cov2cor(t(A) %*% A)
for(j in 1:card_patterns){
yyy = matrix(runif((d-1)^2)*2-1, ncol=d-1)
SigmaS[[j]]= (d-t1)*as.matrix(Sigma[pattern[[j]],pattern[[j]]])/d +
t1*cov2cor(t(yyy) %*% yyy)/d
}
little_decisions = logical(length = M)
for (i in 1:M){
#### generate dataset
X = data.frame(matrix(nrow = d*n, ncol = d))
for (i in 1:d){
X[(1+(i-1)*n):(i*n), pattern[[i]]] = mvrnorm(n, rep(0, d-1), SigmaS[[i]])
}
X = as.matrix(X)
### run little's test
little_decisions[i] = little_test(X, alpha = 0.05, type = "cov")
}
return(mean(little_decisions))
}
#### parallel using parallel
bootstrap_power = function(t1){
#### POPULATION LEVEL ######
v = 1:d
pattern = list()
for (i in 1:d){
pattern[[i]] = v[-i]
}
card_patterns = length(pattern)
SigmaS=list()
A = matrix(runif(d^2)*2-1, ncol=d)
Sigma = cov2cor(t(A) %*% A)
for(j in 1:card_patterns){
yyy = matrix(runif((d-1)^2)*2-1, ncol=d-1)
SigmaS[[j]]= (d-t1)*as.matrix(Sigma[pattern[[j]],pattern[[j]]])/d +
t1*cov2cor(t(yyy) %*% yyy)/d
}
our_decisions = logical(length = M)
for (i in 1:M){
#### generate dataset
X = data.frame(matrix(nrow = d*n, ncol = d))
for (i in 1:d){
X[(1+(i-1)*n):(i*n), pattern[[i]]] = mvrnorm(n, rep(0, d-1), SigmaS[[i]])
}
X = as.matrix(X)
### run our tests
our_decisions[i] = MCAR_corr_test(X, alpha = 0.05, B = 99, type = "p")
}
return(mean(our_decisions))
}
xxx = (0:7)/2
### work in parallel
registerDoFuture()
plan(multicore)
RNGkind("L'Ecuyer-CMRG")
set.seed(232)
start.time = Sys.time()
R = foreach(kkk = xxx, .combine = 'c') %dorng% computeR_kkk(kkk)
little_power = foreach(kkk = xxx, .combine = 'c') %dorng% little_power(kkk)
matrix(rep(1, 4), ncol = 4)
matrix(rep(1, 24), ncol = 4)
unique(matrix(rep(1, 24), ncol = 4))
dim(unique(matrix(rep(1, 24), ncol = 4)))
dim(unique(matrix(rep(1, 24), ncol = 4)))[1]
setwd("~/Documents/GitHub/MCAR")
source("computeR.R")
source("little_test.R")
source("bootstrap_test.R")
source("find_SigmaS.R")
source("indexConsistency.R")
library(missMethods)
library(MASS)
library(norm)
library(foreach)
library(doSNOW)
library(doParallel)
library(future)
library(parallel)
library(foreach)
library(doRNG)
library(doFuture)
library(future.apply)
# ######### example 1 on 3-cycle ############
# alpha = 0.05
# n = 200
# MC = 10
# d = 5
#
# # Select the copula
# cp = claytonCopula(param = c(1), dim = d)
# # Generate the multivariate distribution (in this case it is just bivariate) with normal and t marginals
# P = mvdc(copula = cp, margins = c(rep("exp",d)),
#          paramMargins = rep(list(1),d) )
# data = rMvdc(n, P)
#
#
# bootstrap_power = function(p){
#   ###### SAMPLE LEVEL, REPEATING THE TEST MC TIMES #######
#   our_decisions = logical(length = MC)
#   for (i in 1:MC){
#
#     #### generate dataset from patter S = {{1,2},{2,3},{1,3}}
#     X = delete_MCAR(data, p, c(1,3,5))
#     print("------------------------------------------------------------------")
#     print(i)
#     print("------------------------------------------------------------------")
#
#     ### run our tests
#     our_decisions[i] = MCAR_meancovTest(X, alpha = 0.05, B = 99, type = "np")
#   }
#   return(mean(our_decisions))
# }
#
# little_power = function(p){
#   little_decisions = logical(length = MC)
#   for (i in 1:MC){
#
#     #### generate dataset from patter S = {{1,2},{2,3},{1,3}}
#     X = delete_MCAR(data, p, c(1,3,5))
#     print("------------------------------------------------------------------")
#     print(i)
#     print("------------------------------------------------------------------")
#
#     ### run little's tests
#     little_decisions[i] = little_test(X, alpha = 0.05)
#   }
#
#   return(mean(little_decisions))
# }
#
# ######## USING FOREACH AND DORNG
# registerDoFuture()
# plan(multisession)
# RNGkind("L'Ecuyer-CMRG")
# set.seed(232)
#
# start.time = Sys.time()
#
# xxx = seq(0.03, 0.3, length.out=7)
#
# little_errorI = foreach(p = xxx, .combine = 'c') %dorng% little_power(p)
# our_errorI = foreach(p = xxx, .combine = 'c') %dorng% bootstrap_power(p)
#
# end.time = Sys.time()
# time.taken = round(end.time - start.time,2)
# time.taken
#
# plot(seq(0.03, 0.3, length.out=10), little_errorI, col="green", ylim = c(0,1), pch=18, xlab = "", ylab = "", type="b")
# lines(seq(0.03, 0.3, length.out=10), our_errorI, col="blue", pch=18, type = "b")
# abline(h = alpha, col="red")
# legend("center",
#        legend = c("Little's type I error", "Our type I error"),
#        col = c("green", "blue"),
#        pch = c(18, 18))
######## simulation of power, if data are MAR with censoring
alpha = 0.05
n = 200
MC = 10
d = 5
little_power = c()
our_power = c()
d = 5
# Select the copula
cp = claytonCopula(param = c(1), dim = d)
# Generate the multivariate distribution (in this case it is just bivariate) with normal and t marginals
P = mvdc(copula = cp, margins = c(rep("exp",d)),
paramMargins = rep(list(1),d) )
data = rMvdc(n, P)
for(p in seq(0.03, 0.3, length.out=10)){
little_decisions = c()
our_decisions = c()
for (i in 1:MC){
#### generate dataset from patter S = {{1,2},{2,3},{1,3}}
X = delete_MCAR(data, p, c(1,3,5))
print("------------------------------------------------------------------")
print(i)
print("------------------------------------------------------------------")
little_decisions = c(little_decisions, little_test(X, alpha))
our_decisions = c(our_decisions, MCAR_corr_test(X, alpha, B = 99))
}
little_power = c(little_power, mean(little_decisions))
our_power = c(our_power, mean(our_decisions))
}
plot(seq(0.03, 0.3, length.out=10), little_power, col="green", ylim = c(0,1), pch=18, xlab = "", ylab = "")
points(seq(0.03, 0.3, length.out=10), our_power, col="blue", pch=18)
abline(h = alpha, col="red")
legend("center",
legend = c("Little's power", "Our power"),
col = c("green", "blue"),
pch = c(18, 18))
setwd("~/Documents/GitHub/MCAR")
source("computeR.R")
source("little_test.R")
source("bootstrap_test.R")
source("find_SigmaS.R")
source("indexConsistency.R")
library(missMethods)
library(MASS)
library(norm)
library(foreach)
library(doSNOW)
library(doParallel)
library(future)
library(parallel)
library(foreach)
library(doRNG)
library(doFuture)
library(future.apply)
# ######### example 1 on 3-cycle ############
# alpha = 0.05
# n = 200
# MC = 10
# d = 5
#
# # Select the copula
# cp = claytonCopula(param = c(1), dim = d)
# # Generate the multivariate distribution (in this case it is just bivariate) with normal and t marginals
# P = mvdc(copula = cp, margins = c(rep("exp",d)),
#          paramMargins = rep(list(1),d) )
# data = rMvdc(n, P)
#
#
# bootstrap_power = function(p){
#   ###### SAMPLE LEVEL, REPEATING THE TEST MC TIMES #######
#   our_decisions = logical(length = MC)
#   for (i in 1:MC){
#
#     #### generate dataset from patter S = {{1,2},{2,3},{1,3}}
#     X = delete_MCAR(data, p, c(1,3,5))
#     print("------------------------------------------------------------------")
#     print(i)
#     print("------------------------------------------------------------------")
#
#     ### run our tests
#     our_decisions[i] = MCAR_meancovTest(X, alpha = 0.05, B = 99, type = "np")
#   }
#   return(mean(our_decisions))
# }
#
# little_power = function(p){
#   little_decisions = logical(length = MC)
#   for (i in 1:MC){
#
#     #### generate dataset from patter S = {{1,2},{2,3},{1,3}}
#     X = delete_MCAR(data, p, c(1,3,5))
#     print("------------------------------------------------------------------")
#     print(i)
#     print("------------------------------------------------------------------")
#
#     ### run little's tests
#     little_decisions[i] = little_test(X, alpha = 0.05)
#   }
#
#   return(mean(little_decisions))
# }
#
# ######## USING FOREACH AND DORNG
# registerDoFuture()
# plan(multisession)
# RNGkind("L'Ecuyer-CMRG")
# set.seed(232)
#
# start.time = Sys.time()
#
# xxx = seq(0.03, 0.3, length.out=7)
#
# little_errorI = foreach(p = xxx, .combine = 'c') %dorng% little_power(p)
# our_errorI = foreach(p = xxx, .combine = 'c') %dorng% bootstrap_power(p)
#
# end.time = Sys.time()
# time.taken = round(end.time - start.time,2)
# time.taken
#
# plot(seq(0.03, 0.3, length.out=10), little_errorI, col="green", ylim = c(0,1), pch=18, xlab = "", ylab = "", type="b")
# lines(seq(0.03, 0.3, length.out=10), our_errorI, col="blue", pch=18, type = "b")
# abline(h = alpha, col="red")
# legend("center",
#        legend = c("Little's type I error", "Our type I error"),
#        col = c("green", "blue"),
#        pch = c(18, 18))
######## simulation of power, if data are MAR with censoring
alpha = 0.05
n = 200
MC = 10
d = 5
little_power = c()
our_power = c()
d = 5
# Select the copula
cp = claytonCopula(param = c(1), dim = d)
# Generate the multivariate distribution (in this case it is just bivariate) with normal and t marginals
P = mvdc(copula = cp, margins = c(rep("exp",d)),
paramMargins = rep(list(1),d) )
data = rMvdc(n, P)
for(p in seq(0.03, 0.3, length.out=10)){
little_decisions = c()
our_decisions = c()
for (i in 1:MC){
#### generate dataset from patter S = {{1,2},{2,3},{1,3}}
X = delete_MCAR(data, p, c(1,3,5))
print("------------------------------------------------------------------")
print(i)
print("------------------------------------------------------------------")
little_decisions = c(little_decisions, little_test(X, alpha))
our_decisions = c(our_decisions, MCAR_meancovTest(X, alpha, B = 99))
}
little_power = c(little_power, mean(little_decisions))
our_power = c(our_power, mean(our_decisions))
}
plot(seq(0.03, 0.3, length.out=10), little_power, col="green", ylim = c(0,1), pch=18, xlab = "", ylab = "")
points(seq(0.03, 0.3, length.out=10), our_power, col="blue", pch=18)
abline(h = alpha, col="red")
legend("center",
legend = c("Little's power", "Our power"),
col = c("green", "blue"),
pch = c(18, 18))
######### example 1 on 3-cycle ############
alpha = 0.05
n = 200
MC = 10
d = 5
# Select the copula
cp = claytonCopula(param = c(1), dim = d)
# Generate the multivariate distribution (in this case it is just bivariate) with normal and t marginals
P = mvdc(copula = cp, margins = c(rep("exp",d)),
paramMargins = rep(list(1),d) )
data = rMvdc(n, P)
bootstrap_power = function(p){
###### SAMPLE LEVEL, REPEATING THE TEST MC TIMES #######
our_decisions = logical(length = MC)
for (i in 1:MC){
#### generate dataset from patter S = {{1,2},{2,3},{1,3}}
X = delete_MCAR(data, p, c(1,3,5))
print("------------------------------------------------------------------")
print(i)
print("------------------------------------------------------------------")
### run our tests
our_decisions[i] = MCAR_meancovTest(X, alpha = 0.05, B = 99, type = "np")
}
return(mean(our_decisions))
}
little_power = function(p){
little_decisions = logical(length = MC)
for (i in 1:MC){
#### generate dataset from patter S = {{1,2},{2,3},{1,3}}
X = delete_MCAR(data, p, c(1,3,5))
print("------------------------------------------------------------------")
print(i)
print("------------------------------------------------------------------")
### run little's tests
little_decisions[i] = little_test(X, alpha = 0.05)
}
return(mean(little_decisions))
}
######## USING FOREACH AND DORNG
registerDoFuture()
plan(multisession)
RNGkind("L'Ecuyer-CMRG")
set.seed(232)
start.time = Sys.time()
xxx = seq(0.03, 0.3, length.out=7)
little_errorI = foreach(p = xxx, .combine = 'c') %dorng% little_power(p)
our_errorI = foreach(p = xxx, .combine = 'c') %dorng% bootstrap_power(p)
clear
clear()
